<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.CodeDom"#>
<#@ import namespace="System.CodeDom.Compiler"#>
<#@ import namespace="System.IO"#>
<#@ import namespace="Yagasoft.XrmMockGenerator.Model"#>
<#@ import namespace="Yagasoft.XrmMockGenerator.Model.Control"#>
import { UserSettingsMock, EntityMock, ContextMock, IContextComponents, ClientContextMock, IXrmGeneratorComponents, XrmMockGenerator, IEntityComponents, ItemCollectionMock, UiMock, FormSelectorMock, FormItemMock, ControlMock, OptionSetValueMock, IUiComponents, IOptionSetAttributeComponents, OptionSetAttributeMock, IDateAttributeComponents, INumberAttributeComponents, NumberAttributeMock, ILookupAttributeComponents, LookupAttributeMock, StringAttributeMock, IStringAttributeComponents, DateAttributeMock, IBooleanAttributeComponents, BooleanAttributeMock } from "xrm-mock";

<# if(templateModel.IsGenerateOnlineCode == true) { #>
import { CrmService, CrmConnectionConfig } from "node-dcrm-service";
import * as sinon from "sinon";

var jsdom = require("jsdom");
const { JSDOM } = jsdom;
const { window } = new JSDOM();
const { document } = (new JSDOM('')).window;
global["document"] = document;
global["$"] = global["jQuery"] = require("jquery")(window);
<# } #>


/**
 * Model generated by the "xrm-mock Generator" tool available in the XrmToolBox or as the NuGet package "xrm-mock-Generator"
 */
export namespace XrmModel
{
	abstract class CrmEntityModel<TFormNames>
	{
		abstract entityName: string;
		abstract context: Context;
		abstract crmAttributes: CrmAttribute[];
		abstract forms: Form[];
		activeForm: TFormNames;
	}

	interface IHasId { id: string; }
	interface IHasLabels { labels: Map<number, string>; }
	interface ICanVisible { isVisible: boolean; }
	interface ICanDisabled { isDisabled: boolean; }

	class Form implements IHasId
	{
		id: string;
		name: string;
		tabs: Tab[];

		constructor(obj: Form)
		{
			Object.assign<Form, Form>(this, obj);
		}
	}

	class Tab implements IHasId, IHasLabels, ICanVisible
	{
		id: string;
		labels: Map<number, string>;
		isVisible: boolean;
		sections: Section[];

		constructor(obj: Tab)
		{
			Object.assign<Tab, Tab>(this, obj);
		}
	}

	class Section implements IHasId, IHasLabels, ICanVisible
	{
		id: string;
		labels: Map<number, string>;
		isVisible: boolean;
		controls: Control[];

		constructor(obj: Section)
		{
			Object.assign<Section, Section>(this, obj);
		}
	}

	class CrmAttribute
	{
		attributeType: string;
		name: string;
		requiredLevel: string;
		format: string;
		options: Map<number, Map<number, string>>;
		min: number;
		max: number;
		precision: number;
		maxLength: number;
		defaultBoolValue: boolean;
		initialValue: number;
        
		constructor(obj: CrmAttribute)
		{
			Object.assign<CrmAttribute, CrmAttribute>(this, obj);
		}
	}

	abstract class Control implements IHasLabels, ICanVisible
	{
		name: string;
		labels: Map<number, string>;
		isVisible: boolean;

		constructor(obj: Control)
		{
			Object.assign<Control, Control>(this, obj);
		}
	}

	class FieldControl extends Control implements ICanDisabled
	{
		isDisabled: boolean;

		constructor(obj: FieldControl)
		{
			super(obj);
			Object.assign<FieldControl, FieldControl>(this, obj);
		}
	}

	class GridControl extends Control
	{
		constructor(obj: GridControl)
		{
			super(obj);
			Object.assign<GridControl, GridControl>(this, obj);
		}
	}

	class Context
	{ 
		userId: string;
		username: string;
		userFullName: string;
		isGuidedHelpEnabled: boolean;
		userLanguageCode: number;
		timeZoneBias: number;
		userRoles: string[];
		organisationUrl: string;
		isAutoSaveEnabled: boolean;
		orgLanguageCode: number;
		organisationName: string;
		themeName: string;
		crmVersion: string;

		constructor(obj: Context)
		{
			Object.assign<Context, Context>(this, obj);
		}
	}

	export class ContextParams
	{
		client: Xrm.Client;
		clientState: Xrm.ClientState;
		userSettings: UserSettingsMock;
	}

	export class ModelBuilder<TEntity extends CrmEntityModel<TEntity["activeForm"]>>
	{
		private recordId: string;
		private entity: EntityMock;
		private context: ContextMock;
		private ui: UiMock;
		private attributes: Xrm.Attributes.Attribute[] = [];
		private form: Form;

		private formType: XrmEnum.FormType
		private isBuilt: boolean;

<# if(templateModel.IsGenerateOnlineCode == true) { #>
		private crmService: CrmService
<# } #>
    
		constructor(private rawModel: TEntity, recordId: string = "00000000-0000-0000-0000-000000000000")
		{
			this.recordId = recordId;
			this.form = this.rawModel.forms.find(form => true);
		}

		selectForm(formName: TEntity["activeForm"])
		{
			if (this.isBuilt)
			{
				throw new Error("Model already built.");
			}

			this.form = this.rawModel.forms.find(form => form.name === formName);
		}

		buildContext(parameters_url?: ContextMock | ContextParams | string, url?: string)
		{
			if (this.isBuilt)
			{
				throw new Error("Model already built.");
			}

			const rawContext = this.rawModel.context;

			if (parameters_url == null || typeof(parameters_url) === "string")
			{
				this.context = new ContextMock(<IContextComponents>
					{
						clientContext: new ClientContextMock("Web", "Online"),
						userSettings: new UserSettingsMock(
							<UserSettingsMock>
							{
								isGuidedHelpEnabled: rawContext.isGuidedHelpEnabled,
								isHighContrastEnabled: false,
								isRTL: false,
								userId: rawContext.userId,
								userName: rawContext.username,
								languageId: rawContext.userLanguageCode,
								securityRoles: rawContext.userRoles
							}),
						clientUrl: rawContext.organisationUrl || parameters_url,
						currentTheme: rawContext.themeName,
						isAutoSaveEnabled: rawContext.isAutoSaveEnabled,
						orgLcid: rawContext.orgLanguageCode,
						orgUniqueName: rawContext.organisationName,
						timeZoneOffset: rawContext.timeZoneBias,
						userId: rawContext.userId,
						userLcid: rawContext.userLanguageCode,
						userName: rawContext.userFullName,
						userRoles: rawContext.userRoles,
						version: rawContext.crmVersion
					});
			}
			else if (parameters_url instanceof ContextMock)
			{
				this.context = parameters_url;
			}
			else if (parameters_url instanceof ContextParams)
			{
				const parameters = <ContextParams>parameters_url;

				this.context = new ContextMock(<IContextComponents>
					{
						clientContext: new ClientContextMock(parameters.client, parameters.clientState),
						userSettings: parameters.userSettings,
						clientUrl: rawContext.organisationUrl || url,
						currentTheme: rawContext.themeName,
						isAutoSaveEnabled: rawContext.isAutoSaveEnabled,
						orgLcid: rawContext.orgLanguageCode,
						orgUniqueName: rawContext.organisationName,
						timeZoneOffset: rawContext.timeZoneBias,
						userId: parameters.userSettings.userId,
						userLcid: parameters.userSettings.languageId,
						userName: parameters.userSettings.userName,
						userRoles: parameters.userSettings.securityRoles,
						version: rawContext.crmVersion
					});
			}
		}

		buildModel(): void
		{
			if (this.isBuilt)
			{
				throw new Error("Model already built.");
			}

			if (this.context == null)
			{
				this.buildContext();
			}

			this.buildAttributes();
			this.buildEntity();
			this.buildUi();

			XrmMockGenerator.initialise(<IXrmGeneratorComponents>
				{
					entity: this.entity,
					ui: this.ui,
					context: this.context,
					process: null
				});

			this.buildTabs();

			this.isBuilt = true;
		}

<# if(templateModel.IsGenerateOnlineCode == true) { #>
		enableOnlineWebApi(config: CrmConnectionConfig): Promise<CrmService>
		{
			if (!this.isBuilt)
			{
				throw new Error("Model must be built first before enabling online connection.");
			}

			this.crmService = new CrmService(config);

			this.setupXrmWebApiMocks();
			this.setupJqueryMocks(config);

			return this.crmService.initialise().then(e => this.crmService);
		}
 <# } #>
   
		private buildAttributes(): void
		{
			for (const attribute of this.rawModel.crmAttributes)
			{
				const attributeType = attribute.attributeType;
				const params =
				{
					name: attribute.name,
					attributeType: attribute.attributeType,
					requiredLevel: attribute.requiredLevel,
					format: attribute.format
				};
				let attributeMock;

				switch (attributeType)
				{
					case "optionset":
						const optionsMock: OptionSetValueMock[] = []
						attribute.options.forEach((value, key) => { optionsMock.push(new OptionSetValueMock(value.get(this.context.userLcid), key)) });
						const optionSetParams = <IOptionSetAttributeComponents>params;
						optionSetParams.options = optionsMock;
						optionSetParams.initialValue = attribute.initialValue;
						attributeMock = new OptionSetAttributeMock(optionSetParams);
						break;
					case "datetime":
						attributeMock = new DateAttributeMock(<IDateAttributeComponents>params);
					case "integer":
					case "double":
					case "decimal":
					case "money":
						const numberParams = <INumberAttributeComponents>params;
						numberParams.min = attribute.min;
						numberParams.max = attribute.max;
						numberParams.precision = attribute.precision;
						attributeMock = new NumberAttributeMock(numberParams);
						break;
					case "lookup":
						const lookupParams = <ILookupAttributeComponents>params;
						lookupParams.isPartyList = null;
						attributeMock = new LookupAttributeMock(lookupParams);
						break;
					case "string":
					case "memo":
						const stringParams = <IStringAttributeComponents>params;
						stringParams.maxLength = attribute.maxLength;
						attributeMock = new StringAttributeMock(stringParams);
						break;
					case "boolean":
						const booleanParams = <IBooleanAttributeComponents>params;
						booleanParams.initialValue = attribute.defaultBoolValue;
						attributeMock = new BooleanAttributeMock(booleanParams);
						break;
					default:
						console.log(`WARNING: Adding attribute '${attribute.name}' as String attribute due to unsupported '${attributeType}' type.`);
						const defaultParams = <IStringAttributeComponents>params;
						attributeMock = new StringAttributeMock(defaultParams);
				}

				this.attributes.push(attributeMock);
			}
		}

		private buildEntity(): void
		{
			this.entity = new EntityMock(<IEntityComponents>
				{
					entityName: `${this.rawModel.entityName}`,
					id: `{${this.recordId}}`,
					attributes: new ItemCollectionMock<Xrm.Attributes.Attribute>(this.attributes)
				});
		}

		private buildUi(): void
		{
			this.ui = new UiMock(<IUiComponents>
				{
					formSelector: new FormSelectorMock(new ItemCollectionMock<FormItemMock>(
						this.rawModel.forms.map(form =>
							new FormItemMock(
								{
									currentItem: form.id === this.form.id,
									formType: this.formType,
									id: form.id,
									label: form.name,
								}))))
				});
		}

		private buildTabs(): void
		{
			for (const tab of this.form.tabs) 
			{
				XrmMockGenerator.Tab.createTab(tab.id, tab.labels.get(this.context.userLcid), tab.isVisible, "collapsed", null,
					new ItemCollectionMock<Xrm.Controls.Section>(this.buildSections(tab)));
			}
		}

		private buildSections(tab: Tab): Xrm.Controls.Section[]
		{
			const sections: Xrm.Controls.Section[] = [];

			for (const section of tab.sections)
			{
				sections.push(
					XrmMockGenerator.Section.createSection(section.id, section.labels.get(this.context.userLcid), section.isVisible, null,
						new ItemCollectionMock<Xrm.Controls.Control>(this.buildControls(section))));
			}

			return sections;
		}

		private buildControls(section: Section): Xrm.Controls.Control[]
		{
			const controls: Xrm.Controls.Control[] = [];

			for (const control of section.controls)
			{
				const controlParams: any = { name: control.name, label: control.labels.get(this.context.userLcid), visible: control.isVisible };
				let controlMock: ControlMock;

				if (control instanceof GridControl)
				{
					controlParams.entityName = this.entity;
					controlMock = XrmMockGenerator.Control.createGrid(controlParams);
				}
				else if (control instanceof FieldControl)
				{
					const attribute = this.attributes.find(attribute => attribute.getName() === control.name);

					const missingAttributeMessage = `WARNING: Skipped adding control '${control.name}' due to missing attribute.`;

					if (!attribute)
					{
						console.log(missingAttributeMessage);
						continue;
					}

					controlParams.attribute = attribute;

					const fieldcontrol = <FieldControl>control;
					controlParams.disabled = fieldcontrol.isDisabled

					const rawAttribute = this.rawModel.crmAttributes.find(attribute => attribute.name === control.name);

					if (!rawAttribute)
					{
						console.log(missingAttributeMessage);
						continue;
					}

					const attributeType = rawAttribute.attributeType;

					switch (attributeType)
					{
						case "optionset":
							const optionsMock: OptionSetValueMock[] = []
							rawAttribute.options.forEach((value, key) => { optionsMock.push(new OptionSetValueMock(value.get(this.context.userLcid), key)) });
							controlParams.options = optionsMock;
							controlMock = XrmMockGenerator.Control.createOptionSet(controlParams);
							break;
						case "datetime":
							controlParams.showTime = attribute.getFormat() === "datetime";
							controlMock = XrmMockGenerator.Control.createDate(controlParams);
							break;
						case "integer":
						case "double":
						case "decimal":
						case "money":
							controlMock = XrmMockGenerator.Control.createNumber(controlParams);
							break;
						case "lookup":
							controlMock = XrmMockGenerator.Control.createLookup(controlParams);
							break;
						case "string":
						case "memo":
							controlMock = XrmMockGenerator.Control.createString(controlParams);
							break;
						case "boolean":
							controlMock = XrmMockGenerator.Control.createBoolean(controlParams);
							break;
						default:
							console.log(`WARNING: Adding control '${control.name}' as String control due to unsupported '${attributeType}' type.`);
							controlMock = XrmMockGenerator.Control.createString(controlParams);
					}
				}

				controls.push(controlMock);
			}

			return controls;
		}

<# if(templateModel.IsGenerateOnlineCode == true) { #>
		private retrieveEntityWebApiName =
			(logicalName: string): Promise<string> =>
				this.crmService.get(`/api/data/v8.2/EntityDefinitions(LogicalName='${logicalName}')?$select=LogicalCollectionName`)
					.then(e => e.body.LogicalCollectionName);

		private setupXrmWebApiMocks()
		{
			sinon.stub(Xrm.WebApi, "createRecord").callsFake((entityLogicalName: string, data: any) => this.retrieveEntityWebApiName(entityLogicalName)
				.then(webApiName => this.crmService.post(`/api/data/v8.2/${webApiName}`, data)
					.then(e => new RegExp(`${webApiName}\\((.*?)\\)`).exec(e.headers["odata-entityid"])[1])));
			sinon.stub(Xrm.WebApi, "updateRecord").callsFake((entityLogicalName: string, id: string, data: any) => this.retrieveEntityWebApiName(entityLogicalName)
				.then(webApiName => this.crmService.patch(`/api/data/v8.2/${webApiName}(${id})`, data)
					.then(e => new RegExp(`${webApiName}\\((.*?)\\)`).exec(e.headers["odata-entityid"])[1])));
			sinon.stub(Xrm.WebApi, "deleteRecord").callsFake((entityLogicalName: string, id: string) => this.retrieveEntityWebApiName(entityLogicalName)
				.then(webApiName => this.crmService.delete(`/api/data/v8.2/${webApiName}(${id})`)
					.then(e => id)));
			sinon.stub(Xrm.WebApi, "retrieveRecord").callsFake((entityLogicalName: string, id: string, options?: string) => this.retrieveEntityWebApiName(entityLogicalName)
				.then(webApiName => this.crmService.get(`/api/data/v8.2/${webApiName}(${id})${options}`)
					.then(e => e.body)));
			sinon.stub(Xrm.WebApi, "retrieveMultipleRecords").callsFake((entityLogicalName: string, options?: string, maxPageSize?: number) => this.retrieveEntityWebApiName(entityLogicalName)
				.then(webApiName => this.crmService.get(`/api/data/v8.2/${webApiName}${options}`, new Map<string, string>([["Prefer", `odata.maxpagesize=${maxPageSize ? maxPageSize : 5000}`]]))
					.then(e => <Xrm.RetrieveMultipleResult>{ entities: e.body.value, nextLink: e.body["@odata.nextLink"] })));
		}

		private setupJqueryMocks(config: CrmConnectionConfig)
		{
			const createJqueryStubPromise =
				(method, url, data?, successCallback?, errorCallback?): any =>
				{
					const deferred = $.Deferred();

					let dataProcessed;

					if (data)
					{
						dataProcessed = (data as string) ? JSON.parse(<string>data) : data;
					}

					this.crmService[method](url.replace(config.baseUrl, ''), dataProcessed)
						.then(e =>
						{
							const xhr =
								<JQuery.jqXHR>
								{
									status: e.statusCode, statusText: e.statusCodeMessage,
									getResponseHeader: name => e.headers[name.toLowerCase()]
								};

							if (successCallback)
							{
								(<any>successCallback)(e.body, "success", xhr);
							}

							deferred.resolve(e.body, "success", xhr);
						})
						.catch(e =>
						{
							const xhr =
								<JQuery.jqXHR>
								{
									status: e.statusCode, statusText: e.statusCodeMessage,
									getResponseHeader: name => e.headers[name.toLowerCase()]
								};

							if (errorCallback)
							{
								(<any>errorCallback)(xhr, "error", e.statusCodeMessage);
							}

							deferred.reject(xhr, "error", e.statusCodeMessage);
						});


					return deferred.promise();
				};

			sinon.stub($, "ajax").callsFake(
				(ajaxSettings_url: string | JQuery.AjaxSettings, ajaxSettings: JQuery.AjaxSettings) =>
				{
					if (typeof (ajaxSettings_url) === "string")
					{
						ajaxSettings.url = ajaxSettings_url;
					}
					else
					{
						ajaxSettings = ajaxSettings_url;
					}

					return createJqueryStubPromise((ajaxSettings.method || ajaxSettings.type).toLowerCase(),
						ajaxSettings.url, ajaxSettings.data, ajaxSettings.success, ajaxSettings.error)
				});

			sinon.stub($, "getJSON").callsFake((url: string,
				success_data: JQuery.jqXHR.DoneCallback | JQuery.PlainObject | string,
				success: JQuery.jqXHR.DoneCallback) =>
				createJqueryStubPromise("get", url,
					typeof (success_data) === "function" ? null : success_data,
					typeof (success_data) === "function" ? success_data : success));

			const getPostMock =
				(url_settings: string | JQuery.UrlAjaxSettings,
					success_data: JQuery.jqXHR.DoneCallback | JQuery.PlainObject | string,
					dataType_success?: string | JQuery.jqXHR.DoneCallback,
					success?: JQuery.jqXHR.DoneCallback, method?: string) =>
				{
					const settings =
						typeof (url_settings) === "string"
							? <JQuery.UrlAjaxSettings>
							{
								method: method || "get",
								url: url_settings as string
							}
							: url_settings;

					return createJqueryStubPromise((settings.method || settings.type).toLowerCase(),
						settings.url,
						typeof (success_data) === "function" ? (typeof (dataType_success) === "string" ? dataType_success : null) : success_data,
						typeof (success_data) === "function" ? success_data : typeof (dataType_success) === "string" ? success : dataType_success,
						settings.error)
				};

			sinon.stub($, "get").callsFake((url_settings, success_data, dataType_success, success) =>
				getPostMock(url_settings, success_data, dataType_success, success, "get"));
			sinon.stub($, "post").callsFake((url_settings, success_data, dataType_success, success) =>
				getPostMock(url_settings, success_data, dataType_success, success, "post"));
		}
<# } #>	}
	<# 
		foreach (var model in templateModel.Models)
		{
	#> 
	type <#=CheckString(model.EntityName)#>_Forms =
		<# foreach (var form in model.Forms) { #>"<#=CheckString(form.Name)#>" |  <# } #>null;

	export class <#=CheckString(model.EntityName)#> extends CrmEntityModel<<#=CheckString(model.EntityName)#>_Forms>
	{
		entityName = "<#=CheckString(model.EntityName)#>";
		context = new Context(<Context>
			{
				userId: "<#=CheckString(model.Context.UserId.ToString())#>",
				username: <#=ToLiteral(CheckString(model.Context.Username))#>,
				userFullName: <#=ToLiteral(CheckString(model.Context.UserFullName))#>,
				isGuidedHelpEnabled: <#=CheckString(model.Context.IsGuidedHelpEnabled.ToString().ToLower())#>,
				userLanguageCode: <#=CheckString(model.Context.UserLanguageCode.ToString())#>,
				timeZoneBias: <#=CheckString(model.Context.TimeZoneBias.ToString())#>,
				userRoles:
					[
			<#
				foreach (var role in model.Context.UserRoles)
				{
			#>			"<#=CheckString(role.ToString())#>",
			<#
				}
			#>		],
				organisationUrl: "<#=CheckString(model.Context.OrganisationUrl)#>",
				isAutoSaveEnabled: <#=CheckString(model.Context.IsAutoSaveEnabled.ToString().ToLower())#>,
				orgLanguageCode: <#=CheckString(model.Context.OrgLanguageCode.ToString())#>,
				organisationName: "<#=CheckString(model.Context.OrganisationName)#>",
				themeName: <#=ToLiteral(CheckString(model.Context.ThemeName))#>,
				crmVersion: "<#=CheckString(model.Context.CrmVersion)#>"
			});
		crmAttributes =
			[
			<#
				foreach (var attribute in model.CrmAttributes)
				{
			#>	new CrmAttribute(<CrmAttribute>
					{
						attributeType: "<#=CheckString(attribute.AttributeType)#>", name: "<#=CheckString(attribute.Name)#>", requiredLevel: "<#=CheckString(attribute.RequiredLevel, "none")#>", format: "<#=CheckString(attribute.Format)#>",
						min: <#=CheckString(attribute.Min?.ToString() ?? "null")#>, max: <#=CheckString(attribute.Max?.ToString() ?? "null")#>, precision: <#=CheckString(attribute.Precision?.ToString() ?? "null")#>,
						maxLength: <#=CheckString(attribute.MaxLength?.ToString() ?? "null")#>,
						defaultBoolValue: <#=CheckString(attribute.DefaultBoolValue?.ToString().ToLower() ?? "null")#>, initialValue: <#=CheckString(attribute.InitialValue?.ToString() ?? "null")#>,
						options: new Map(
							[
				<#
					if (attribute.Options != null) {
					foreach (var option in attribute.Options)
					{
				#>				[<#=CheckString(option.Key.ToString())#>,
									new Map(
										[
					<#
						foreach (var label in option.Value)
						{
					#>						[<#=CheckString(label.Key.ToString())#>, <#=ToLiteral(CheckString(label.Value))#>]
					<#
						}
					#>					])
								],
				<#
					}
					}
				#>			])
					}),
			<#
				}
			#>];
		forms =
			[
			<#
				foreach (var form in model.Forms)
				{
			#>	new Form(<Form>
					{
						id: "<#=CheckString(form.Id)#>", name: "<#=CheckString(form.Name)#>",
						tabs:
							[
				<#
					foreach (var tab in form.Tabs)
					{
				#>				new Tab(<Tab>
									{
										id: "<#=CheckString(tab.Id)#>", isVisible: <#=CheckString(tab.IsVisible.ToString().ToLower())#>,
										labels: new Map(
											[
					<#
						foreach (var label in tab.Labels)
						{
					#>							[<#=label.Key#>, <#=ToLiteral(CheckString(label.Value))#>],
					<#
						}
					#>						]),
										sections:
											[
						<#
							foreach (var section in tab.Sections)
							{
						#>						new Section(<Section>
													{
														id: "<#=CheckString(section.Id)#>", isVisible: <#=CheckString(section.IsVisible.ToString().ToLower())#>,
														labels: new Map(
															[
							<#
								foreach (var label in section.Labels)
								{
							#>									[<#=label.Key#>, <#=ToLiteral(CheckString(label.Value))#>],
							<#
								}
							#>								]),
														controls:
															[
								<#
									foreach (var control in section.Controls.OfType<FieldControl>())
									{
								#>								new FieldControl(<FieldControl>
																	{
																		name: "<#=CheckString(control.Name)#>", isVisible: <#=CheckString(control.IsVisible.ToString().ToLower())#>, isDisabled: <#=CheckString(control.IsDisabled.ToString().ToLower())#>,
																		labels: new Map(
																			[
									<#
										foreach (var label in control.Labels)
										{
									#>											[<#=label.Key#>, <#=ToLiteral(CheckString(label.Value))#>],
																			])
									<#
										}
									#>								}),
								<#
									}
								#><#
									foreach (var control in section.Controls.OfType<GridControl>())
									{
								#>								new GridControl(<GridControl>
																	{
																		name: "<#=CheckString(control.Name)#>", isVisible: <#=CheckString(control.IsVisible.ToString().ToLower())#>,
																		labels: new Map(
																			[
									<#
										foreach (var label in control.Labels)
										{
									#>											[<#=label.Key#>, <#=ToLiteral(CheckString(label.Value))#>],
																			])
									<#
										}
									#>								}),
								<#
									}
								#>							]
													}),
						<#
							}
						#>					]
									}),
				<#
					}
				#>			]
					}),
			<#
				}
			#>];
	}
<#
		}
#>}
<#+
    // Credit :http://stackoverflow.com/questions/323640/can-i-convert-a-c-sharp-string-value-to-an-escaped-string-literal
    private static string ToLiteral(string input)
    {
        using (var writer = new StringWriter())
        {
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }
    }

	public string CheckString(string value, string defaultValue = "null")
	{
		return value ?? defaultValue;
	}
#>
